'''
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。

小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。

在冒泡排序中，每次只能交换相邻的两个元素。

小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符， 则在所有可能的排序方案中，冒泡排序的总交换次数是最少的。

例如，对于字符串 lan 排序，只需要 1次交换。对于字符串 qiao排序，总共需要 4 次交换。

小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100次交 换，可是他忘了吧这个字符串记下来，现在找不到了。

请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对 该串的字符排序，正好需要 100 次交换。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。

解题思路：
条件：①最短字符串； ②最小字典序； ③100次交换；
①
完全逆序交换次数为：n*(n-1)/2
字符串长度为15时完全逆序交换次数为105
即最短字符串长度为15
②
最小字典序，a→o
③
完全逆序是 o~a，又少交换5次，则需要把第6位的数，往前交换五次，排在首位
'''
print("jonmlkihgfedcba")
 
#python冒泡排序法：
s = list(map(str,input().split(" ")))# 输入列表，以空格分隔，返回列表
for i in range(len(s)):
    for j in range(len(s)-i-1):
        if s[j] > s[j+1] :#升序排序
            s[j], s[j+1] = s[j+1], s[j] 
for i in s:
    print(i,end=" ")
